+++
title = "一些计算机科学和技术中的概念区分"
date = "2018-12-02"
lastmod = "2018-12-22"
description = ""
tags = [
    "Java"
]
categories = [
    "技术"
]
+++

本篇博客记录了些计算机科学和技术中常见的概念的差别，属于基础知识。

<!--more-->

### URI，URL和URN的区别
1）URI

URI 是 uniform resource identifier 的首字母大写，即统一资源标识符，用来唯一地标识一个资源。

2）URL

URL 是 uniform resource locator 的首字母大写，即统一资源定位符，是一种具体的 URI，即 URL 不仅可以用来标识一个资源，还指明了如何获取这个资源。

3）URN

URN 是 uniform resource name 的首字母大写，即统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。

也就是说，URI 是以一种抽象的、高层次概念定义统一资源标识，而URL和URN则是具体的资源标识方式，URL 和 URN 都是一种 URI。

在 Java 的 URI 中，一个 URI 实例可以代表绝对的，也可以是相对的，只要其符合 URI 的语法规则。

而 URL 类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，schema 必须被指定。

### Web 服务器和应用服务器

1）Web服务器

Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL，与客户端的网络浏览器配合，只能发送静态页面的内容。因为Web服务器主要支持的协议就是HTTP，所以通常情况下HTTP服务器和WEB服务器是相等的。Web服务器包括Nginx，Apache，IIS等

2）应用服务器

应用程序服务器让多个用户可以同时使用应用程序，通常是客户创建的应用程序。应用服务器包括WebLogic，JBoss，Tomcat，websphere等。

### 127.0.0.1 和 localhost

1、含义不同：

* `localhost` 也叫 `local` ，是一个域名，可以调用 gethostname() 解析出对应的 IP 地址，其值为：`hosts` 文件中的值，正确的解释是: 本地服务器
* `127.0.0.1`，是一个 IPv4 的地址， 在 `windows` 等系统的正确解释是: 本机地址(本机服务器)

2、与防火墙和网卡的关系

* `localhost` 是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。

* `127.0.0.1` 是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。

### 用户态和内核态
    
操作系统需要两种CPU状态：

* 内核态（Kernel Mode）：运行操作系统程序。
* 用户态（User Mode）：运行用户程序。

指令划分：

* 特权指令：只能由操作系统使用，用户程序不能使用的指令。例如，启动I/O，内存清零，修改程序状态字，设置时钟，允许/禁止终端，停机。
* 非特权指令：用户程序可以使用的指令，例如，控制转移，算术运算，取数指令，访管指令（使用户程序从用户态进入内核态）

特权级别：

特权环：R0，R1，R2，R3。

R0相当于内核态，R3相当于用户态。

不同级别能够运行不同的指令集合。

CPU 状态之间的转换：
* 用户态 ——> 内核态：唯一途径是通过中断、异常、陷入机制（访管指令）
* 内核态 ——> 用户态：设置程序状态字PSW。

内核态与用户态的区别：

* 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上之时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。
* 当程序运行在0级特权级上时，就可以称之为运行在内核态。
* 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。
* 这两种状态的主要差别是：
  1、处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理机是可以被抢占的。
  
  2、处于内核态执行中的进程，则能访问所有的内存空间和对象，且所占有的处理机是不允许被抢占的。

通常来说，以下三种情况会导致用户态到内核态的切换：

* 系统调用，这是用户态进程主动请求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。比如，fork() 函数实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如 Linux 的 int 80h 中断。
* 异常，当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
* 外围设备的中断，当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的处理程序。如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这三种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

### 进程与线程

#### 定义
* 进程：具有一定独立功能的程序关于某个数据集合上的一次执行活动，是系统进行资源分配和调度的一个独立单位。
* 线程：是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程本身基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（例如，程序计数器、一组寄存器和栈等），但是它可以与同属于一个进程的其他线程共享进程所拥有的全部资源。

#### 关系

一个进程可以创建和撤销一个线程；同一个进程中的多个线程之间可以并发执行。

相对于进程而言，线程是一个更加接近于执行体的概念，可以与同进程中的其他线程共享全局变量、静态变量等数据，但拥有自己的栈空间，拥有独立的执行序列。

#### 区别

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。

进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响；而线程只是一个进程中的不同执行路径。

线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，资源耗费较大，效率要差一些。

但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

总结：

* 一个程序至少有一个进程，一个进程至少有一个线程。
* 线程的划分尺度小于进程，使得多线程程序的并发性高。
* 进程在执行过程中拥有独立的内存单元，而同一个进程中的多个线程共享内存，从而极大地提高了程序的运行效率。
* 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
* 从逻辑角度来看，多线程的意义在于在一个应用程序中，有多个执行部分可以并发执行。但是操作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配，这是进程和线程的重要区别。

#### 优缺点

线程和进程在使用上各有优缺点：
线程执行开销小，但不利于资源的管理和保护；而进程则正好相反。
另外，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

### AB 测试
AB测试是为Web或App界面或流程制作A/B两个版本，在同一时间维度，分别让组成成分相同（相似）的访客群组随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析评估出最好版本正式采用。

在App和Web开发阶段，程序中添加用于制作A/B版本和采集数据的代码由此引起的开发和QA的工作量很大，ROI（return on investment）很低。AB测试的场景受到限制，App和Web发布后，无法再增加和更改AB测试场景。额外的A/B测试代码，增加了App和Web后期维护成本。

### 持续集成/持续部署/持续交付

持续集成是指软件个人研发的部分向软件整体部分交付，频繁进行集成以便更快地发现其中的错误。

持续部署是指当交付的代码通过评审之后，自动部署到生产环境，这意味着所有通过了一系列的自动化测试的改动都将自动部署到生产环境。

持续交付涵盖了软件交付端到端的整个周期，其覆盖面不仅仅包括编码，还包括：设计、测试、部署、运维、运营等等。
